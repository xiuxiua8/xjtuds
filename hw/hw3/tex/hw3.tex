\documentclass[UTF8]{ctexart}
%\documentclass[11pt]{article} %指定文档的类型和基本格式。这里选择了article类，字体大小为11磅。
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx,enumerate} %加载了一些宏包，这些宏包提供了额外的功能和格式设定，例如数学符号、文本特殊符号、排版布局等。

\usepackage{listings}
\usepackage[dvipsnames]{xcolor}

%\usepackage[utf8]{inputenc}
%\usepackage{xeCJK} % Added for Chinese support
%\setCJKmainfont{SimSum} % Set the Chinese font, you can change it to any font you have


%\def\Name{zilong}
\def\Name{王子隆}  
\def\SID{2221411126}  
\def\Homework{3} 
\def\Session{Autumn 2023} 


\title{DS--Autumn 2023 --- Homework \Homework Solutions} 
\author{\Name, SID \SID} 
\markboth{DS--\Session\  Homework \Homework\ \Name}{DS--\Session\ Homework \Homework\ \Name} 
\pagestyle{myheadings} 
\date{\today} 

\newenvironment{qparts}{\begin{enumerate}[{(}a{)}]}{\end{enumerate}} %定义了一个新的环境qparts，用于创建带有小括号标记的题目部分。
%\def\endSolutionsmark{$\mathcal{X} \mathcal{I} \mathcal{U} $} %定义了证明结束标记为一个方框符号。
\newenvironment{Solutions}{\par{\bf Solutions}:}%{\endSolutionsmark\smallskip} %定义了一个新的环境Solutions，用于书写数学证明。


\lstdefinestyle{javastyle}{ %%定义了一个样式mystyle，指定了Java语言，设定了代码的基本样式、注释样式、关键词样式等等
    language=Java,
    basicstyle=\ttfamily\small, % 设置代码字体为大一些
    commentstyle=\color{OliveGreen},
    keywordstyle=\color{RoyalBlue},
    numberstyle=\tiny\color{gray},
    numbers=left,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
}

\lstdefinestyle{cppstyle}{
    language=C++,
    basicstyle=\ttfamily\small,
    commentstyle=\color{OliveGreen},
    keywordstyle=\color{RoyalBlue},
    numberstyle=\tiny\color{gray},
    numbers=left,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
}

\textheight=9in
\textwidth=6.5in
\topmargin=-.75in
\oddsidemargin=0.25in
\evensidemargin=0.25in %设置了页面的尺寸和边距。


%\lstset{style=mystyle}

\begin{document}
\maketitle

%Collaborators: PUT SOMETHING HERE (LIST OF YOUR COLLABORATORS, OR WRITE NONE)

\begin{abstract}
    %Abstract goes here...
    二叉树实现及应用 面向过程 面向对象

    定义
    
    二叉树遍历（ 九种方法 递归 非递归 * 2 * 3 

    preorder inorder postorder 

    复杂度 时间空间

    最坏情况 最好情况 最废空间 最省空间

    二叉树的主要性质

    语法制导编辑器

    修改数据结构 （不借助外力 stack queue 

    三叉链表 利用空指针（增加标识

    哈夫曼树 定义性质应用

    二叉树分类

    BST

    ASL 平均查找长度
    
\end{abstract}













\section*{1. 二叉树实现}
\begin{qparts}
    \item 
    功能实现
    
    \item
    应用 
\end{qparts}

\subsection*{1.1 面向过程}

\begin{Solutions}
\begin{enumerate} % for numbers

\item 结构体
ArrayDeque.java
\begin{lstlisting}
/** Array based list.
*  @author zilong
*/


\end{lstlisting}


\end{enumerate}

\end{Solutions}


\subsection*{1.2 面向对象 }

\begin{Solutions}

\begin{enumerate}
\item interface 
BinaryTree.java

\begin{lstlisting}[style=cppstyle]
    #include <iostream>
    #include "../hw2/SeqStack.cpp"
    //#define NULL nullptr
    #define cin std::cin 
    #define cout std::cout
    #define endl std::endl
    
    
    template <class T>
    class BinaryTreeNode{
    private:
        T data;           			
        BinaryTreeNode<T>*  left; 	
        BinaryTreeNode<T>*  right; 	
    
    
    public:
        BinaryTreeNode(); 	                   
        BinaryTreeNode(const T& elem);	
        BinaryTreeNode(const T& elem, BinaryTreeNode<T>* l, BinaryTreeNode<T>* r);
        ~BinaryTreeNode(){};
        T value() const;				
        BinaryTreeNode<T>*  leftchild() const;	
        BinaryTreeNode<T>*  rightchild() const;	
        void  setLeftchild(BinaryTreeNode<T>*);	
        void  setRightchild(BinaryTreeNode<T>*);	
        void  setValue(const T& val);		
        bool  isLeaf() const;		
    };
    
    
    
    template<class T>
    BinaryTreeNode<T>::BinaryTreeNode(){
        data = T();
        left = nullptr;
        right = nullptr;
    }
    
    template<class T>
    BinaryTreeNode<T>::BinaryTreeNode(const T& elem){
        data = elem;
        left = nullptr;
        right = nullptr;
    }
    
    template<class T>
    BinaryTreeNode<T>::BinaryTreeNode(const T& elem, BinaryTreeNode<T>* l, BinaryTreeNode<T>* r){
        data = elem;
        left = l;
        right = r;
    }
    
    
    template<class T>
    T BinaryTreeNode<T>::value() const{
        return this->data;
    }
    
    template<class T>
    BinaryTreeNode<T>*  BinaryTreeNode<T>::leftchild() const{
        return this->left;
    }
    
    template<class T>
    BinaryTreeNode<T>*  BinaryTreeNode<T>::rightchild() const{
        return this->right;
    }
    
    template<class T>
    void BinaryTreeNode<T>::setLeftchild(BinaryTreeNode<T>* Lchild){
        this->left = Lchild;
    }
    
    template<class T>
    void BinaryTreeNode<T>::setRightchild(BinaryTreeNode<T>* Rchild){
        this->right = Rchild;
    }
    
    template<class T>
    void BinaryTreeNode<T>::setValue(const T& Value){
        this->data = Value;
    }
    
    template<class T>
    bool BinaryTreeNode<T>::isLeaf() const{
        return false;
    }
    
    
    enum Tag{L, R, M};
    template <class T>
    class StackNode{
    public:
        BinaryTreeNode<T>* pointer;
        Tag tag;
        StackNode() {pointer = nullptr; tag = L;}
        StackNode(BinaryTreeNode<T>* ptr,Tag tg){pointer = ptr; tag =tg;}
    };
    
    
    
    
    template <class T>
    class BinaryTree{
    protected:
        BinaryTreeNode<T>* root;        			
    public:
        BinaryTree() {root = nullptr;} 			
        BinaryTree(BinaryTreeNode<T>* r) {root = r;}
        ~BinaryTree() { DeleteBinaryTree(root); };    	
        bool isEmpty() { return root==nullptr; };  		
        void visit(const BinaryTree<T>& curr){cout << curr.root->value() << " ";} 
        BinaryTreeNode<T>*& Root() {return root;};   	
        void CreateTree(const T& data, BinaryTreeNode<T>* lefttree, BinaryTreeNode<T>* righttree);
        void CreateTree(BinaryTreeNode<T> *&r); 
        void DeleteBinaryTree(BinaryTreeNode<T>* root); 
    
        void PreOrder(BinaryTreeNode<T>* root); 	
        void InOrder(BinaryTreeNode<T>* root); 	
        void PostOrder(BinaryTreeNode<T>* root); 	
        void PreOrderLikeRecusion(BinaryTreeNode<T>* root);
        void InOrderLikeRecusion(BinaryTreeNode<T>* root);
        void PostOrderLikeRecusion(BinaryTreeNode<T>* root);
        void PreOrderWithoutRecusion(BinaryTreeNode<T>* root);
        void InOrderWithoutRecusion(BinaryTreeNode<T>* root); 
        void PostOrderWithoutRecusion(BinaryTreeNode<T>* root);
        void LevelOrder(BinaryTreeNode<T>* root);	
    };
    
    
    template<class T> 
    void BinaryTree<T>::CreateTree(const T& data, BinaryTreeNode<T>* leftTree, BinaryTreeNode<T>* rightTree) {
        root = new BinaryTreeNode<T>(data, leftTree, rightTree);
        BinaryTree(root);
    }
    
    
    
    
    template<class T> 
    void BinaryTree<T>::DeleteBinaryTree(BinaryTreeNode<T>* Root){
        if (Root != NULL) {
            DeleteBinaryTree(Root->leftchild());   
            DeleteBinaryTree(Root->rightchild());  
            Root->~BinaryTreeNode();
        }
    }
    


\end{lstlisting}

\end{enumerate}

\end{Solutions}






\clearpage

\newpage

%\iffalse

\section*{2.二叉树遍历}

Traversals. When we iterate over a tree, we call this a “tree traversal”.


Depth First Traversals. 

We have three depth first traversals: Pre-order, in-order and post-order. 
In a pre-order traversal, we visit a node, then traverse its children. 
In an in-order traversal, we traverse the left child, visit a node, then traverse the right child. 
In a post-order traversal, we traverse both children before visiting. 
These are very natural to implement recursively. 
Pre-order and post-order generalize naturally to trees with arbtirary numbers of children. 
In-order only makes sense for binary trees.

\begin{qparts}
\item 

二叉树遍历（ 九种方法 递归 非递归 * 2 * 3 

preorder inorder postorder 

复杂度 时间空间

最坏情况 最好情况 最废空间 最省空间


\end{qparts}

\subsection*{preorder}

\subsubsection*{recursive}
\begin{Solutions}
遍历指 走一遍只走一遍
递归算法的关键————写好两个条件 1.递归条件 2. 结束条件

    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::PreOrder(BinaryTreeNode<T>* root){
    if (root == NULL)  return;
    visit(root);			
    PreOrder(root->leftchild());		
    PreOrder(root->rightchild());		
}
    \end{lstlisting}
\end{Solutions}
\subsubsection*{nonrecursive}
\begin{enumerate}
    \item recursivelike
    
    
    \begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::PreOrderLikeRecusion(BinaryTreeNode <T> * root){
    SeqStack<BinaryTreeNode<T>*> tStack(10);
    BinaryTreeNode<T>* pointer = root;
    while(!tStack.IsEmpty() || pointer){
        if (pointer){
            visit(pointer);               
            tStack.Push(pointer);                  
            pointer = pointer->leftchild();     
        } else{	                                    
            pointer = tStack.Pop();               
            //tStack.Pop();                            
            pointer = pointer->rightchild(); }
    }
}
    \end{lstlisting}
    \end{Solutions}
    \item other way 
    \begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::PreOrderWithoutRecusion(BinaryTreeNode <T> * root){
    SeqStack<BinaryTreeNode<T>*> tStack(10);
    BinaryTreeNode<T>* pointer = root;
    if (!pointer) {return;};
    tStack.Push(pointer);
    while(!tStack.IsEmpty()){  //use the feature of stack
        pointer = tStack.Pop();
        visit(pointer);
        if(pointer->rightchild()){
            tStack.Push(pointer->rightchild());// first in then out
        }
        if (pointer->leftchild()){
            tStack.Push(pointer->leftchild());
        }
    }
    //does queue do the same work?
}   
    \end{lstlisting}
    \end{Solutions}
\end{enumerate}


\subsection*{inorder}
\subsubsection*{recursive}
\begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::InOrder(BinaryTreeNode<T>* root){
    if (root == NULL) return;
    InOrder(root->leftchild());
    visit(root);
    InOrder(root->rightchild());
}        
    \end{lstlisting}

\end{Solutions}
\subsubsection*{nonrecursive}
\begin{enumerate}
    \item recursivelike
    
    与前序指针行进类似，访问次序不同
    \begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::InOrderLikeRecusion(BinaryTreeNode <T> * root){
    SeqStack<BinaryTreeNode<T>*> tStack(10);
    BinaryTreeNode<T>* pointer = root;
    while(!tStack.IsEmpty() || pointer){
        if (pointer){            
            tStack.Push(pointer);                   
            pointer = pointer->leftchild();     
        } else{	                                    
            pointer = tStack.Pop();  
            visit(pointer);
            //tStack.Push(pointer);               
            //tStack.Pop();                            
            pointer = pointer->rightchild(); }  
    }
}
    \end{lstlisting}
    \end{Solutions}
    \item other way 
    \begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::InOrderWithoutRecusion(BinaryTreeNode <T> * root){
    SeqStack<StackNode<T>*> tStack(10);
    //BinaryTreeNode<T>* pointer = root;
    StackNode<T>* Tagptr = new StackNode<T>();
    Tagptr->pointer = root;
    
    if (!Tagptr->pointer) {return;};
    tStack.Push(Tagptr);
    while(!tStack.IsEmpty()){  
        Tagptr = tStack.Pop();
        if (Tagptr->tag == L) {
            if(Tagptr->pointer->rightchild()){
                StackNode<T>* tem = new StackNode<T>(Tagptr->pointer->rightchild(), L);
                tStack.Push(tem);
            }
            StackNode<T>* tem = new StackNode<T>(Tagptr->pointer, R);
            tStack.Push(tem);
            if (Tagptr->pointer->leftchild()){
                StackNode<T>* tem = new StackNode<T>(Tagptr->pointer->leftchild(), L);
                tStack.Push(tem);
            } 
        } else visit(Tagptr->pointer);
    }
}
    \end{lstlisting}        
    
    \end{Solutions} 
\end{enumerate}


\subsection*{postorder}
\subsubsection*{recursive}
\begin{Solutions}
    \begin{lstlisting}[style=cppstyle]
        template<class T>
void BinaryTree<T>::PostOrder(BinaryTreeNode<T>* root){
    if (root == NULL) return;
    PostOrder(root->leftchild());
    PostOrder(root->rightchild());
    visit(root);
}
    \end{lstlisting}
\end{Solutions}
\subsubsection*{nonrecursive}
\begin{enumerate}
    \item recursivelike
    \begin{Solutions}
        \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::PostOrderLikeRecusion(BinaryTreeNode <T> * root){
    SeqStack<StackNode<T>* > tStack(10);
    StackNode<T>* Tagptr = new StackNode<T>(root, L);

    while (!tStack.IsEmpty() || Tagptr->pointer != nullptr ){
        while (Tagptr->pointer != nullptr) {
            StackNode<T>* tem = new StackNode<T>(Tagptr->pointer, L);
            tStack.Push(tem);
            Tagptr->pointer = Tagptr->pointer->leftchild();
        }
        if (!tStack.IsEmpty()) {
            Tagptr = tStack.Pop();
            if (Tagptr->tag == L ) {
                StackNode<T>* tem = new StackNode<T>(Tagptr->pointer, R);
                tStack.Push(tem);
                Tagptr->pointer = Tagptr->pointer->rightchild();
            } else {
                visit(Tagptr->pointer);
                Tagptr->pointer = nullptr;
            }
        }
    }
}
        \end{lstlisting}   
    \end{Solutions}
    \item other way 
    \begin{Solutions}
        \begin{lstlisting}[style=cppstyle]
template<class T>
void BinaryTree<T>::PostOrderWithoutRecusion(BinaryTreeNode <T> * root){
    SeqStack<StackNode<T>*> tStack(10);
    //BinaryTreeNode<T>* pointer = root;
    StackNode<T>* Tagptr = new StackNode<T>();
    Tagptr->pointer = root;
    
    if (!Tagptr->pointer) {return;};
    tStack.Push(Tagptr);
    while(!tStack.IsEmpty()){  
        Tagptr = tStack.Pop();
        if (Tagptr->tag == L) {
            StackNode<T>* tem = new StackNode<T>(Tagptr->pointer, R);
            tStack.Push(tem);
            if (Tagptr->pointer->rightchild()){
                StackNode<T>* tem = new StackNode<T>(Tagptr->pointer->rightchild(), L);
                tStack.Push(tem);
            }
            if (Tagptr->pointer->leftchild()){
                StackNode<T>* tem = new StackNode<T> (Tagptr->pointer->leftchild(), L);
                tStack.Push(tem);
            }
        } else if (Tagptr->tag == R) {
            StackNode<T>* tem = new StackNode<T>(Tagptr->pointer, M);
            tStack.Push(tem);
        } else {
            visit(Tagptr->pointer);
        }
    }
}
        \end{lstlisting}    
    \end{Solutions}
\end{enumerate}


\subsection*{复杂度分析}
\begin{enumerate}
    \item   复杂度 时间空间
    
    n 为节点数 每个节点都在栈里走了两遍 故为2n

    空间为栈的长度，树的高度

    \begin{tabular}{|l|r|r|} \hline
        traversalMethod & Time & Space \\\hline
        PreOrder & $2N$ & $height$ \\
        InOrder & $2N$ & $height$ \\
        PostOrder & $3N$ & $\log _2 N$ \\\hline
    \end{tabular}
    

    \item   最坏情况 最好情况 %/最废空间 最省空间
    

    \begin{tabular}{|l|r|r|} \hline   
    traversalMethod & Bestcase & worstcase \\\hline
        PreOrder & only rightchild & only leftchild \\
        InOrder & only rightchild & only leftchild \\
        PostOrder & FBT with least height & only leftchild \\\hline
    \end{tabular}
\end{enumerate}

\subsection*{层次遍历}

Level Order Traversal. 

A level-order traversal visits every item at level 0, then level 1, then level 2, and so forth.

\begin{enumerate}
    \item   借助外力 stack queue 逻辑
    \begin{lstlisting}[style=cppstyle]
        
template<class T>
void BinaryTree<T>::LevelOrder(BinaryTreeNode <T> * root){
    SeqQueue<BinaryTreeNode<T>*> Queue(16);
    Queue.InQueue(root);
    while(!Queue.IsEmpty()) {
        //cout << "Starting Level Order Traversal..." << endl;
        BinaryTreeNode<T>* pointer = Queue.OutQueue();
        if (pointer->leftchild()){
            Queue.InQueue(pointer->leftchild());
        }
        if (pointer->rightchild()){
            Queue.InQueue(pointer->rightchild());
        }
        visit(pointer);
    }
}

    \end{lstlisting}
\end{enumerate}









\newpage
\section*{3.二叉树的定义、主要性质、定理}
\begin{qparts}
    \item 递归定义及基本术语
    \item 分类 顺序存储 链式存储
    \item 性质*5
\end{qparts}

\subsection*{definition}
\begin{Solutions}
    \begin{enumerate}
        \item   a recursive definition
        
        Trees. 
        
        A tree consists of a set of nodes and a set of edges connecting the nodes, 
        where there is only one path between any two nodes. 
        A tree is thus a graph with no cycles and all vertices connected.

        Definition. 

        we can define a binary tree as a either a null link or a node with a left link and a right link, 
        each references to (disjoint) subtrees that are themselves binary trees.



    \end{enumerate}


\end{Solutions}

\subsection*{category}
\begin{Solutions}

    \begin{enumerate}
        \item sequential structure
        \item list structure
    \end{enumerate}

\end{Solutions}


\subsection*{properties quality character}
\begin{Solutions}
    \begin{enumerate}
    \item i \& $2^ {i-1}$ floor
    \item k \& $2^k - 1$ all the tree 
    \item $ n_0 = n_2 + 1 $ 
    \item height = $[\log _2 n ] + 1$
    \item structure of root, Lchild, Rchild 
    \end{enumerate}
    
\end{Solutions}






\newpage
\section*{4.证明}
YOUR ANSWER GOES HERE

\subsection*{something to prove}
\begin{Solutions}
    \begin{enumerate}
        \item 给定tree 遍历序列唯一 给定位置唯一存在（ 顺序唯一
        
        idea： 给定位置唯一存在 
        \item 中序遍历猜想 + 先序猜想
        \item 遍历时的性质*5
        \item n node  2*n pointer  N-1 in use 
    \end{enumerate}

\end{Solutions}





\newpage
\section*{5.修改数据结构 }
我们利用stack记录路径以便遍历：右边值or访问结点值（后序）、（中 反一下），
利用Queue记录下一层访问节点。
有没有方法可以不借助外力？
修改原来的数据结构！

idea:
\begin{enumerate}
    \item 利用现有Data Structure没有用的空间
    \item 使用标识/取值范围，准确定义
    \item 利用已有知识，线性表后继
\end{enumerate}

\begin{qparts}
    \item 
    利用空指针（增加标识
    
    \item
    三叉链表
\end{qparts}

\subsection*{1.1 利用空指针}
发现：

$n$个节点，$2n$个pointer，$n-1$ 有用， $n+1$ 没用。

可以通过增加标识，利用好这些pointer。

\begin{Solutions}
\begin{enumerate} 
\item ThreadBT.java 

as known as TBT.
\begin{lstlisting}




\end{lstlisting}
\end{enumerate}
\end{Solutions}


\subsection*{1.2 三叉链表 }

\begin{Solutions}

\begin{enumerate}
\item interface 
List.java

\begin{lstlisting}[style=cppstyle]
public interface List<Item> 
\end{lstlisting}

\end{enumerate}

\end{Solutions}


\clearpage



\newpage


\newpage
\section*{6.Huffman tree}

\begin{qparts}
    \item 递归定义及基本术语
    \item 分类 顺序存储 链式存储
    \item 应用*4
\end{qparts}

\subsection*{definition}
\begin{Solutions}
    \begin{enumerate}
        \item   a recursive definition
    \end{enumerate}


\end{Solutions}

\subsection*{category}
\begin{Solutions}

    \begin{enumerate}
        \item sequential structure
        \item list structure
    \end{enumerate}

\end{Solutions}


\subsection*{properties quality character}
\begin{Solutions}
    \begin{enumerate}
    \item i \& $2^ {i-1}$ floor
    \item k \& $2^k - 1$ all the tree 
    \item $ n_0 = n_2 + 1 $
    \item height = $[\log _2 n ] + 1$
    \item structure of root, Lchild, Rchild 
    \end{enumerate}
    
\end{Solutions}

\subsection*{application}
\begin{enumerate}
\item 编码 code
\item 压缩非等长
\item 判定

一般的数据大多呈正态分布，Huffmantree可加快速度
\item 加密解密 

MD5 加密解密，2次异或
\end{enumerate}

\newpage
\section*{7.Binary searching/sorting Tree }
search -- 不可重复
sort -- 可重复
\paragraph{BST}
A binary search tree (BST) is a binary tree where each node has a Comparable key (and an associated value) 
and satisfies the restriction that the key in any node is 
larger than the keys in all nodes in that node's left subtree 
and smaller than the keys in all nodes in that node's right subtree.

\subparagraph{delete}
Deletion is quite a bit more complex, since when one removes an internal node, 
one can’t just let its children fall off, but must re-attach them somewhere in the tree. 
Obviously, deletion of an external node is easy; 
just replace it with the null tree (see Figure 6.3(a)). 
It’s also easy to remove an internal node that 
is missing one child—just have the other child commit patricide and move up (Figure 6.3(b)). 

When neither child is empty, we can find the successor of the node we want 
to remove—the first node in the right tree, when it is traversed in inorder. 
Now that node will contain the smallest key in the right subtree. 
Furthermore, because it is the first node in inorder, its left child will be null [why?]. 
Therefore, we can replace that node with its right child 
and move its key to the node we are removing, as shown in Figure 6.3(c).

\begin{Solutions}
    \begin{enumerate}
        \item remove 
        \begin{lstlisting}[style=javastyle]
    /** Delete the instance of key from Node that is closest
    *  to the root and return the modified tree. The nodes of
    *  the original tree may be modified. */
    public Node removehelper(Node node, K key) {
        if (node == null) {
            return null;
        }
        if (key.compareTo(node.key) < 0) {
            node.left = removehelper(node.left, key);
        } else if (key.compareTo(node.key) > 0) {
            node.right = removehelper(node.right, key);
        } else if (node.left == null) {
            // Otherwise, we've found key
            return node.right;
        } else if (node.right == null) {
            return node.left;
        } else {
            node.right = swapSmallest(node.right, node);
        }
        return node;
    }
    /** Move the label from the first node in node (in an inorder
    *  traversal) to node R (over-writing the current label of R),
    *  remove the first node of node from node, and return the resulting tree. */
    private Node swapSmallest(Node node, Node R) {
        if (node.left == null) {
            R.key = node.key;
            return node.right;
        } else {
            node.left = swapSmallest(node.left, R);
            return node;
        }
    }
    
        \end{lstlisting}
    \end{enumerate}
\end{Solutions}


\begin{tabular}{|l|r|r|r|} \hline   
    Shape of Tree & Height & add & search \\\hline
    “Bushy” (Best Case) & $\log N$ & $Θ(logN)$ & $Θ(logN)$ \\
    “Spindly” (Worst Case) & $N$ & $Θ(N)$ & $Θ(N)$ \\\hline
\end{tabular}



最大值最小值
中序遍历有序

平均查找长度ASL
insert
create



\newpage
\section*{8.BalancedBinarySortingTree categories}

\paragraph{2-3 Tree}

BST where a node can have 2,3 children
Ensures tree is “bushy” -> height is log(n)


2-3 and 2-3-4 trees. Understand how to search and insert. 
Understand why insertion technique leads to perfect balance.

\subparagraph{Terminology. }

Know that a 2-3 tree is also called a B-Tree of order 3 
and that a 2-3-4 tree is a B-Tree of order 4. 
Know that an M-node is a node with M children, 
e.g. a 4-node is a node containing 3 items and thus with 4 children.


\subparagraph{Performance of trees. }

Tree height is between $log_M N$ and $log_2 N$. 
All paths are of the same height.


\subparagraph{1-1 correspondence between LLRBs and 2-3 trees. }

Understand how to map a 2-3 tree to an LLRB and vice versa. 
You do not need to know how to perform tree operations ‘natively’ on an LLRB.

\paragraph{LLRBs. }

BST such that no node has two red links touching it; perfect black balance; red links lean left.


\textbf{Left Leaning Red Black Tree}


 This is simply an implementation of a 2-3 Tree with the same ideas. 
 Be able to convert between a 2-3 Tree and a LLRB tree. 
 We use red links to indicate two nodes that would be in the same 2-3 Node. 
 In a left leaning RB tree, we arbitrarily enforce that edges are always to the left (for convenience).


\subparagraph{Properties of LLRB's}

Here are the properties of LLRB's:

1-1 correspondence with 2-3 trees.

No node has 2 red links.

There are no red right-links.

Every path from root to leaf has same number of black links (because 2-3 trees have same number of links to every leaf).

Height is no more than 2x height of corresponding 2-3 tree.

\subparagraph{LLRB get}

Exactly the same as regular BST get.

\subparagraph{LLRB performance. }

Perfect black balance ensures worst case performance for get and insert is ~ 2 $log_2 N$.


\subparagraph{LLRB insert. }

You are not responsible for knowing how to insert into an LLRB using rotations and color flipping. 
However, you should know how to convert back and forth between 2-3 trees and LLRBs, 
and you should also know how to insert into 2-3 trees. 
Thus, you should know effectively how one can insert into an LLRB.


\subparagraph{LLRB Tree}
Properties of a 2-3 tree, but implemented like a BST


\subparagraph{Tree rotaions}
We rotateLeft or rotateRight on a node, creating a different but valid BST with the same elements. 
Notice when we rotateLeft(G) we move the node G to be the left child of the new root.


There are two important propertires for LLRBs:

No node ever has 2 red links (It wouldn’t be a valid node in a 2-3 Tree if it did)
Every path from the root to a leaf has the same number of black links. 
This is because every leaf in a 2-3 tree has same numbers of links from root. Therefore, the tree is balanced.
LLRB operations Always insert with a red link at the correct location. 
Then use the following three operations to “fix” or LLRB tree. See slides for visual.

If there is a right leaning red link, rotate that node left.
If there are two consecutive left leaning links, rotate right on the top node.
If there is a node with two red links to children, flip all links with that node.
\newpage
\section*{9.BinaryTree categories}

\newpage
\section*{10.heap}




\subparagraph{Priority Queue. }

A Max Priority Queue (or PQ for short) is an ADT that supports at least the insert and delete-max operations. A MinPQ supposert insert and delete-min.

Tree Representations. Know that there are many ways to represent a tree, and that we use Approach 3b (see lecture slides) for representing heaps, since we know they are complete.

Running times of various PQ implementations. Know the running time of the three primary PQ operations for an unordered array, ordered array, and heap implementation.

\subparagraph{Heap definitions}

The binary heap is a data structure that can efficiently support the basic priority-queue operations. 
In a binary heap, the keys are stored in an array such that each key is guaranteed to be larger than 
(or equal to) the keys at two other specific positions. 
In turn, each of those keys must be larger than (or equal to) two ad- ditional keys, and so forth. 
This ordering is easy to see if we view the keys as being in a binary tree structure 
with edges from each key to the two keys known to be smaller.

Heaps. A max (min) heap is an array representation of a binary tree such that every node is larger (smaller) than all of its children. This definition naturally applies recursively, i.e. a heap of height 5 is composed of two heaps of height 4 plus a parent.




\newpage
\section*{11.Tree and forest}


parent 

child 

child sibling



\newpage
\section*{.BinaryTree in java}

%\fi
\end{document}
